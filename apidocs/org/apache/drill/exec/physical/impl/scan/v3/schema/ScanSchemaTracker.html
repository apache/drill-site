<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>ScanSchemaTracker (Drill : 1.21.2-SNAPSHOT API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.apache.drill.exec.physical.impl.scan.v3.schema, interface: ScanSchemaTracker">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/ScanSchemaTracker.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.apache.drill.exec.physical.impl.scan.v3.schema</a></div>
<h1 title="Interface ScanSchemaTracker" class="title">Interface ScanSchemaTracker</h1>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="AbstractSchemaTracker.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.schema">AbstractSchemaTracker</a></code>, <code><a href="ProjectionSchemaTracker.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.schema">ProjectionSchemaTracker</a></code>, <code><a href="SchemaBasedTracker.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.schema">SchemaBasedTracker</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">ScanSchemaTracker</span></div>
<div class="block">Computes <i>scan output schema</i> from a variety of sources.
 <p>
 The scan operator output schema can be <i>defined</i> or <i>dynamic.</i>

 <h4>Defined Schema</h4>

 The planner computes a defined schema from metadata, as in a typical
 query engine. A defined schema defines the output schema directly:
 the defined schema <b>is</b> the output schema. Drill's planner does not
 yet support a defined schema, but work is in progress to get there for
 some cases.
 <p>
 With a defined schema, the reader is given a fully-defined schema and
 its job is to produce vectors that match the given schema. (The details
 are handled by the <a href="../../../../resultSet/ResultSetLoader.html" title="interface in org.apache.drill.exec.physical.resultSet"><code>ResultSetLoader</code></a>.)
 <p>
 At present, since the planner does not actually provide a defined schema,
 we support it in this class, and verify that the defined schema, if provided,
 exactly matches the names in the project list in the same order.

 <h4>Dynamic Schema</h4>

 A dynamic schema is one defined at run time: the traditional Drill approach.
 A dynamic schema starts with a <i>projection list</i> : a list of column names
 without types.
 This class converts the project list into a dynamic reader schema which is
 a schema in which each column has the type <code>LATE</code>, which basically means
 "a type to be named later" by the reader.

 <h4>Hybrid Schema</h4>

 Some readers support a <i>provided schema</i>, which is an concept similar to,
 but distinct from, a defined schema. The provided schema provides <i>hints</i>
 about a schema. At present, it
 is an extra; not used or understood by the planner. Thus, the projection
 list is independent of the provided schema: the lists may be disjoint.
 <p>
 With a provided schema, the project list defines the output schema. If the
 provided schema provides projected columns, then the provided schema for those
 columns flow to the output schema, just as for a defined schema. Similarly, the
 reader is given a defined schema for those columns.
 <p>
 Where a provided schema differs is that the project list can include columns
 not in the provided schema, such columns act like the dynamic case: the reader
 defines the column type.

 <h4>Projection Types</h4>

 Drill will pass in a project list which is one of three kinds:
 <p><ul>
 <li><code>&gt;SELECT *</code>: Project all data source columns, whatever they happen
 to be. Create columns using names from the data source. The data source
 also determines the order of columns within the row.</li>
 <li><code>&gt;SELECT a, b, c, ...</code>: Project a specific set of columns, identified by
 case-insensitive name. The output row uses the names from the SELECT list,
 but types from the data source. Columns appear in the row in the order
 specified by the <code>SELECT</code>.</li>
 &lt;li<code>&gt;SELECT ...</code>: Project nothing, occurs in <code>&gt;SELECT COUNT(*)</code>
 type queries. The provided projection list contains no (table) columns, though
 it may contain metadata columns.</li>
 </ul>
 Names in the project list can reference any of five distinct types of output
 columns:
 <p><ul>
 <li>Wildcard ("*") column: indicates the place in the projection list to insert
 the table columns once found in the table projection plan.</li>
 <li>Data source columns: columns from the underlying table. The table
 projection planner will determine if the column exists, or must be filled
 in with a null column.</li>
 <li>The generic data source columns array: <code>&gt;columns</code>, or optionally
 specific members of the <code>&gt;columns</code> array such as <code>&gt;columns[1]</code>.
 (Supported only by specific readers.)</li>
 <li>Implicit columns: <code>&gt;fqn</code>, <code>&gt;filename</code>, <code>&gt;filepath</code>
 and <code>&gt;suffix</code>. These reference
 parts of the name of the file being scanned.</li>
 <li>Partition columns: <code>&gt;dir0</code>, <code>&gt;dir1</code>, ...: These reference
 parts of the path name of the file.</li>
 </ul>

 <h4>Empty Schema</h4>

 A special case occurs if the projection list is empty which indicates that
 the query is a <code>COUNT(*)</code>: we need only a count of columns, but none
 of the values. Implementation of the count is left to the specific reader
 as some can optimize this case. The output schema may include a single
 dummy column. In this case, the first batch defines the schema expected
 from all subsequent readers and batches.

 <h4>Implicit Columns</h4>

 The project list can contain implicit columns for data sources which support
 them. Implicit columns are disjoint from data source columns and are provided
 by Drill itself. This class effectively splits the projection list into
 a set of implicit columns, and the remainder of the list which are the
 reader columns.

 <h4>Reader Input Schema</h4>

 The various forms of schema above produce a <i>reader input schema</i>:
 the schema given to the reader. The reader input schema is the set of
 projected columns, minus implicit columns, along with available type
 information.
 <p>
 If the reader can produce only one type
 for each column, then the provided or defined schema should already specify
 that type, and the reader can simply ignore the reader input schema. (This
 feature allows this scheme to be compatible with older readers.)
 <p>
 However, if the reader can convert a column to multiple types, then the
 reader should use the reader input schema to choose a type. If the input
 schema is dynamic (type is <code>LATE</code>), then the reader chooses the
 column type and should chose the "most natural" type.

 <h4>Reader Output Schema</h4>

 The reader proceeds to read a batch of data, choosing types for dynamic
 columns. The reader may provide a subset of projected columns if, say
 the reader reads an older file that is missing some columns or (for a
 dynamic schema), the user specified columns which don't actually exist.
 <p>
 The result is the <i>reader output schema</i>: a subset of the reader
 input schema in which each included column has a concrete type. (The
 reader may have provided extra columns. In this case, the
 <code>ResultSetLoader</code> will have ignored those columns, providing a
 dummy column writer, and omitting non-projected columns from the reader
 output schema.)
 <p>
 The reader output schema is provided to this class which resolves any
 dynamic columns to the concrete type provided by the reader. If the
 column was already resolved, this class ensures that the reader's
 column type matches the resolved type to prevent column type changes.

 <h4>Dynamic Wildcard Schema</h4>

 Traditional query planners resolve the wildcard (<code>*</code>) in the
 planner. When using a dynamic schema, Drill resolves the wildcard at
 run time. In this case, the reader input schema is empty and the reader
 defines the entire set of columns: names and types. This class then
 replaces the wildcard with the columns from the reader.

 <h4>Missing Columns</h4>

 When the reader output schema is a subset of the reader input schema,
 the we have a set of <i>missing columns</i> (also called "null columns").
 A part of the scan framework must invent vectors for these columns. If
 the type is available, then that is the type used, otherwise the missing
 column handler must invent a type (such as the classic
 <code>nullable INT</code> historically used.) If the mode is
 nullable, the column is filled with nulls. If non-nullable, the column
 is filled with a default value. All of this work happens outside of
 this class.
 <p>
 The missing column handler defined its own output schema which is
 resolved by this class identical to how the reader schema is resolved.
 The result is that all columns are now resolved to a concrete type.
 <p>
 Missing columns may be needed even for a wildcard if a first reader
 discovered 3 columns, say, but a later reader encounters only two of
 them.

 <h4>Subsequent Readers and Schema Changes</h4>

 All of the above occurs during the first batch of data. After that,
 the schema is fully defined: subsequent readers will encounter only
 a fully defined schema, which it must handle the same as if the scan
 was given a defined schema.
 <p>
 This rule works file for an explicit project list. However, if the
 project list is dynamic, and contains a wildcard, then the reader
 defines the output schema. What happens if a reader adds columns
 (or a second or later reader discovers new columns)? Traditionally,
 Drill simply adds those columns and sends a <code>OK_NEW_SCHEMA</code>
 (schema change) downstream for other operators to deal with.
 <p>
 This class supports the traditional approach as an option. This class
 also supports a more rational, strict rule: the schema is fixed after
 the first batch. That is, the first batch defines a <i>schema commit
 point</i> after which the scan agrees not to change the schema. In
 this scenario, the first batch defines a schema (and project list)
 given to all subsequent readers. Any new columns are ignored (with
 a warning in the log.)

 <h4>Output Schema</h4>

 All of the above contribute to the <i>output schema</i>: the schema
 sent downstream to the next operator. All of the above work is done to
 either:
 <ul>
 <li>Pass the defined schema to the output, with the reader (and missing
 columns handler) producing columns that match that schema.</li>
 <li>Expand the dynamic schema with details provided by the reader
 (and missing columns hander), including the actual set of columns if
 the dynamic schema includes a wildcard.</li>
 </ul>
 <p>
 Either way, the result is a schema which describes the actual vectors
 sent downstream.

 <h4>Consumers</h4>

 Information from this class is used in multiple ways:
 <ul>
 <li>A project list is given to the <code>ResultSetLoader</code> to specify which
 columns to project to vectors, and which to satisfy with a dummy column
 reader.</li>
 <li>The reader, via the {code SchemaNegotiator} uses the reader input
 schema.</li>
 <li>The reader, via the <code>ResultSetLoader</code> provides the reader output
 schema.</li>
 <li>An implicit column manager handles the various implicit and partition
 directory columns: identifying them then later providing vector values.</li>
 <li>A missing columns handler fills in missing columns.</li>
 </ul>

 <h4>Design</h4>

 Schema resolution is a set of layers of choices. Each level and choice is
 represented by a class: virtual method pick the right path based on class
 type rather than using a large collection of if-statements.

 <h4>Maps</h4>

 Maps present a difficult challenge. Drill allows projection within maps
 and we wish to exploit that in the scan. For example: <code>m.a</code>. The
 column state classes provide a map class. However, the projection notation
 is ambiguous: <code>m.a</code> could be a map <code>`m`</code> with a child column
 <code>'a'</code>. Or, it could be a <code>DICT</code> with a {code VARCHAR} key.
 <p>
 To handle this, if we only have the project list, we use an unresolved
 column state, even if the projection itself has internal structure. We
 use a projection-based filter in the <code>ResultSetLoader</code> to handle
 the ambiguity. The projection filter, when presented with the reader's
 choice for column type, will check if that type is consistent with projection.
 If so, the reader will later present the reader output schema which we
 use to resolve the projection-only unresolved column to a map column.
 (Or, if the column turns out to be a <code>DICT</code>, to a simple unresolved
 column.)
 <p>
 If the scan contains a second reader, then the second reader is given a
 stricter form of projection filter: one based on the actual <code>MAP</code>
 (or <code>DICT</code>) column.
 <p>
 If a defined or provided schema is available, then the schema tracker
 does have sufficient information to resolve the column directly to a
 map column, and the first reader will have the strict projection filter.
 <p>
 A user can project a map column which does not actually exist (or, at
 least, is not known to the first reader.) In that case, the missing
 column logic applies, but within the map. As a result, a second reader
 may encounter a type conflict if it discovers the previously-missing
 column, and finds that the default type conflicts with the real type.
 <p></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Interface</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static enum&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="ScanSchemaTracker.ProjectionType.html" class="type-name-link" title="enum in org.apache.drill.exec.physical.impl.scan.v3.schema">ScanSchemaTracker.ProjectionType</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#applyEarlyReaderSchema(org.apache.drill.exec.record.metadata.TupleMetadata)" class="member-name-link">applyEarlyReaderSchema</a><wbr>(<a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a>&nbsp;readerSchema)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">If a reader can define a schema before reading data, apply that
 schema to the scan schema.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#applyImplicitCols()" class="member-name-link">applyImplicitCols</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Indicate that implicit column parsing is complete.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#applyReaderSchema(org.apache.drill.exec.record.metadata.TupleMetadata,org.apache.drill.common.exceptions.CustomErrorContext)" class="member-name-link">applyReaderSchema</a><wbr>(<a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a>&nbsp;readerOutputSchema,
 <a href="../../../../../../common/exceptions/CustomErrorContext.html" title="interface in org.apache.drill.common.exceptions">CustomErrorContext</a>&nbsp;errorContext)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Once a reader has read a batch, the reader will have provided a type
 for each projected column which the reader knows about.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="ProjectedColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.schema">ProjectedColumn</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#columnProjection(java.lang.String)" class="member-name-link">columnProjection</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;colName)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Return the projection for a column, if any.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../../../../../common/exceptions/CustomErrorContext.html" title="interface in org.apache.drill.common.exceptions">CustomErrorContext</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#errorContext()" class="member-name-link">errorContext</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">The scan-level error context used for errors which may occur before the
 first reader starts.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#expandImplicitCol(org.apache.drill.exec.record.metadata.ColumnMetadata,org.apache.drill.exec.physical.impl.scan.v3.file.ImplicitColumnMarker)" class="member-name-link">expandImplicitCol</a><wbr>(<a href="../../../../../record/metadata/ColumnMetadata.html" title="interface in org.apache.drill.exec.record.metadata">ColumnMetadata</a>&nbsp;resolved,
 <a href="../file/ImplicitColumnMarker.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.file">ImplicitColumnMarker</a>&nbsp;marker)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Drill defines a wildcard to expand not just reader columns, but also
 partition columns.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="MutableTupleSchema.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.schema">MutableTupleSchema</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#internalSchema()" class="member-name-link">internalSchema</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the internal scan schema.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#isResolved()" class="member-name-link">isResolved</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Is the scan schema resolved? The schema is resolved depending on the
 complex lifecycle explained in the class comment.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#missingColumns(org.apache.drill.exec.record.metadata.TupleMetadata)" class="member-name-link">missingColumns</a><wbr>(<a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a>&nbsp;readerOutputSchema)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Identifies the missing columns given a reader output schema.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#outputSchema()" class="member-name-link">outputSchema</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the scan output schema which is a somewhat complicated
 computation that depends on the projection type.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../../../resultSet/impl/ProjectionFilter.html" title="interface in org.apache.drill.exec.physical.resultSet.impl">ProjectionFilter</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#projectionFilter(org.apache.drill.common.exceptions.CustomErrorContext)" class="member-name-link">projectionFilter</a><wbr>(<a href="../../../../../../common/exceptions/CustomErrorContext.html" title="interface in org.apache.drill.common.exceptions">CustomErrorContext</a>&nbsp;errorContext)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">A reader is responsible for reading columns in the reader input schema.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="ScanSchemaTracker.ProjectionType.html" title="enum in org.apache.drill.exec.physical.impl.scan.v3.schema">ScanSchemaTracker.ProjectionType</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#projectionType()" class="member-name-link">projectionType</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#readerInputSchema()" class="member-name-link">readerInputSchema</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">The schema which the reader should produce.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#resolveMissingCols(org.apache.drill.exec.record.metadata.TupleMetadata)" class="member-name-link">resolveMissingCols</a><wbr>(<a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a>&nbsp;missingCols)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">The missing column handler obtains the list of missing columns from
 <code>#missingColumns()</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#schemaVersion()" class="member-name-link">schemaVersion</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Gives the output schema version which will start at some arbitrary
 positive number.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="projectionType()">
<h3>projectionType</h3>
<div class="member-signature"><span class="return-type"><a href="ScanSchemaTracker.ProjectionType.html" title="enum in org.apache.drill.exec.physical.impl.scan.v3.schema">ScanSchemaTracker.ProjectionType</a></span>&nbsp;<span class="element-name">projectionType</span>()</div>
</section>
</li>
<li>
<section class="detail" id="columnProjection(java.lang.String)">
<h3>columnProjection</h3>
<div class="member-signature"><span class="return-type"><a href="ProjectedColumn.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.schema">ProjectedColumn</a></span>&nbsp;<span class="element-name">columnProjection</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;colName)</span></div>
<div class="block">Return the projection for a column, if any.</div>
</section>
</li>
<li>
<section class="detail" id="isResolved()">
<h3>isResolved</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">isResolved</span>()</div>
<div class="block">Is the scan schema resolved? The schema is resolved depending on the
 complex lifecycle explained in the class comment. Resolution occurs
 when the wildcard (if any) is expanded, and all explicit projection
 columns obtain a definite type. If schema change is disabled, the
 schema will not change once it is resolved. If schema change is allowed,
 then batches or readers may extend the schema, triggering a schema
 change, and so the scan schema may move from one resolved state to
 another.
 <p>
 The schema will be fully resolved after the first batch of data arrives
 from a reader (since the reader lifecycle will then fill in any missing
 columns.) The schema may be resolved sooner (such as if a strict provided
 schema, or an early reader schema is available and there are no missing
 columns.)</div>
<dl class="notes">
<dt>Returns:</dt>
<dd> if the schema is resolved, and hence the
 <a href="#outputSchema()"><code>outputSchema()</code></a> is available, <code>false</code> if the schema
 contains one or more dynamic columns which are not yet resolved.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="schemaVersion()">
<h3>schemaVersion</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="element-name">schemaVersion</span>()</div>
<div class="block">Gives the output schema version which will start at some arbitrary
 positive number.
 <p>
 If schema change is allowed, the schema version allows detecting
 schema changes as the scan schema moves from one resolved state to
 the next. Each schema will have a unique, increasing version number.
 A schema change has occurred if the version is newer than the previous
 output schema version.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the schema version. The absolute number is not important,
 rather an increase indicates one or more columns were added at the
 top level or within a map at some nesting level</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="expandImplicitCol(org.apache.drill.exec.record.metadata.ColumnMetadata,org.apache.drill.exec.physical.impl.scan.v3.file.ImplicitColumnMarker)">
<h3>expandImplicitCol</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">expandImplicitCol</span><wbr><span class="parameters">(<a href="../../../../../record/metadata/ColumnMetadata.html" title="interface in org.apache.drill.exec.record.metadata">ColumnMetadata</a>&nbsp;resolved,
 <a href="../file/ImplicitColumnMarker.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.file">ImplicitColumnMarker</a>&nbsp;marker)</span></div>
<div class="block">Drill defines a wildcard to expand not just reader columns, but also
 partition columns. When the implicit column handlers sees that the
 query has a wildcard (by calling <code>#isProjectAll()</code>), the handler
 then determines which partition columns are needed and calls this
 method to add each one.</div>
</section>
</li>
<li>
<section class="detail" id="applyImplicitCols()">
<h3>applyImplicitCols</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a></span>&nbsp;<span class="element-name">applyImplicitCols</span>()</div>
<div class="block">Indicate that implicit column parsing is complete. Returns the implicit
 columns as identified by the implicit column handler, in the order of the
 projection list. Implicit columns do not appear in a reader input schema,
 and it is an error for the reader to produce such columns.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a sub-schema of only implicit columns, in the order in which
 they appear in the output schema</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="applyEarlyReaderSchema(org.apache.drill.exec.record.metadata.TupleMetadata)">
<h3>applyEarlyReaderSchema</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">applyEarlyReaderSchema</span><wbr><span class="parameters">(<a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a>&nbsp;readerSchema)</span></div>
<div class="block">If a reader can define a schema before reading data, apply that
 schema to the scan schema. Allows the scan to report its output
 schema before the first batch of data if the scan schema becomes
 resolved after the early reader schema.</div>
</section>
</li>
<li>
<section class="detail" id="readerInputSchema()">
<h3>readerInputSchema</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a></span>&nbsp;<span class="element-name">readerInputSchema</span>()</div>
<div class="block">The schema which the reader should produce. Depending on the type of
 the scan (specifically, if <code>#isProjectAll()</code> is <code>true</code>),
 the reader may produce additional columns beyond those in the the
 reader input schema. However, for any batch, the reader, plus the
 missing columns handler, must produce all columns in the reader input
 schema.
 <p>
 Formally:<pre><code>
 reader input schema = output schema - implicit col schema
 </code></pre></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the sub-schema which includes those columns which the reader
 should provide, excluding implicit columns</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="missingColumns(org.apache.drill.exec.record.metadata.TupleMetadata)">
<h3>missingColumns</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a></span>&nbsp;<span class="element-name">missingColumns</span><wbr><span class="parameters">(<a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a>&nbsp;readerOutputSchema)</span></div>
<div class="block">Identifies the missing columns given a reader output schema. The reader
 output schema are those columns which the reader actually produced.
 <p>
 Formally:<pre><code>
 missing cols = reader input schema - reader output schema
 </code></pre>
 <p>
 The reader output schema can contain extra, newly discovered columns.
 Those are ignored when computing missing columns. Thus, the subtraction
 is set subtraction: remove columns common to the two sets.</div>
</section>
</li>
<li>
<section class="detail" id="outputSchema()">
<h3>outputSchema</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a></span>&nbsp;<span class="element-name">outputSchema</span>()</div>
<div class="block">Returns the scan output schema which is a somewhat complicated
 computation that depends on the projection type.
 <p>
 For a wildcard schema:<pre><code>
 output schema = implicit cols U reader output schema
 </code></pre>
 <p>
 For an explicit projection:<pre><code>
 output schema = projection list
 </code></pre>
 Where the projection list is augmented by types from the
 provided schema, implicit columns or readers.
 <p>
 A defined schema <i>is</i> the output schema, so:<code><pre>
 output schema = defined schema
 </pre></code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the complete output schema provided by the scan to downstream
 operators. Includes both reader and implicit columns, in the order
 of the projection list or, for a wildcard, in the order of the first
 reader</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="projectionFilter(org.apache.drill.common.exceptions.CustomErrorContext)">
<h3>projectionFilter</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../resultSet/impl/ProjectionFilter.html" title="interface in org.apache.drill.exec.physical.resultSet.impl">ProjectionFilter</a></span>&nbsp;<span class="element-name">projectionFilter</span><wbr><span class="parameters">(<a href="../../../../../../common/exceptions/CustomErrorContext.html" title="interface in org.apache.drill.common.exceptions">CustomErrorContext</a>&nbsp;errorContext)</span></div>
<div class="block">A reader is responsible for reading columns in the reader input schema.
 A reader may read additional columns. The projection filter is passed to
 the <a href="../../../../resultSet/ResultSetLoader.html" title="interface in org.apache.drill.exec.physical.resultSet"><code>ResultSetLoader</code></a> to determine which columns should be projected,
 allowing the reader to be blissfully ignorant of which columns are needed.
 The result set loader provides a dummy reader for unprojected columns.
 (A reader can, via the result set loader, find if a column is projected if
 doing so helps reader efficiency.)
 <p>
 The projection filter is the first line of defense for schema conflicts.
 The {code ResultSetLoader} will query the filter with a full column
 schema. If that schema conflicts with the scan schema for that column,
 this method will raise a <code>UserException</code>, which typically indicates
 a programming error, or a very odd data source in which a column changes
 types between batches.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>errorContext</code> - the reader-specific error context to use if
 errors are found</dd>
<dt>Returns:</dt>
<dd>a filter used to decide which reader columns to project during
 reading</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="applyReaderSchema(org.apache.drill.exec.record.metadata.TupleMetadata,org.apache.drill.common.exceptions.CustomErrorContext)">
<h3>applyReaderSchema</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">applyReaderSchema</span><wbr><span class="parameters">(<a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a>&nbsp;readerOutputSchema,
 <a href="../../../../../../common/exceptions/CustomErrorContext.html" title="interface in org.apache.drill.common.exceptions">CustomErrorContext</a>&nbsp;errorContext)</span></div>
<div class="block">Once a reader has read a batch, the reader will have provided a type
 for each projected column which the reader knows about. For a wildcard
 projection, the reader will have added all the columns that it found.
 This call takes the reader output schema and merges it with the current
 scan schema to resolve dynamic types to concrete types and to add
 newly discovered columns.
 <p>
 The process can raise an exception if the reader projects a column that
 it shouldn't (which is not actually possible because of the way the
 <code>ResultSetLoader</code> works.) An error can also occur if the reader
 provides a type different than that already defined in the scan schema
 by a defined schema, a provided schema, or a previous reader in the same
 scan. In such cases, the reader is expected to have converted its input
 type to the specified type, which was presumably selected because the
 reader is capable of the required conversion.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>readerOutputSchema</code> - the actual schema produced by a reader when
 reading a record batch</dd>
<dd><code>errorContext</code> - the reader-specific error context to use if
 errors are found</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="resolveMissingCols(org.apache.drill.exec.record.metadata.TupleMetadata)">
<h3>resolveMissingCols</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="element-name">resolveMissingCols</span><wbr><span class="parameters">(<a href="../../../../../record/metadata/TupleMetadata.html" title="interface in org.apache.drill.exec.record.metadata">TupleMetadata</a>&nbsp;missingCols)</span></div>
<div class="block">The missing column handler obtains the list of missing columns from
 <code>#missingColumns()</code>. Depending on the scan lifecycle, some of the
 columns may have a type, others may be dynamic. The missing column handler
 chooses a type for any dynamic columns, then calls this method to tell
 the scan schema tracker the now-resolved column type.
 <p>
 Note: a goal of the provided/defined schema system is to avoid the need
 to guess types for missing columns since doing so quite often leads
 to problems further downstream in the query. Ideally, the type of missing
 columns will be known (via the provided or defined schema) to avoid
 such conflicts.</div>
</section>
</li>
<li>
<section class="detail" id="errorContext()">
<h3>errorContext</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../../../common/exceptions/CustomErrorContext.html" title="interface in org.apache.drill.common.exceptions">CustomErrorContext</a></span>&nbsp;<span class="element-name">errorContext</span>()</div>
<div class="block">The scan-level error context used for errors which may occur before the
 first reader starts. The reader will provide a more detailed error context
 that describes what is being read.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the scan-level error context</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="internalSchema()">
<h3>internalSchema</h3>
<div class="member-signature"><span class="return-type"><a href="MutableTupleSchema.html" title="class in org.apache.drill.exec.physical.impl.scan.v3.schema">MutableTupleSchema</a></span>&nbsp;<span class="element-name">internalSchema</span>()</div>
<div class="block">Returns the internal scan schema. Primarily for testing.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the internal mutable scan schema</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small>Copyright &#169; 2023 <a href="https://www.apache.org/">The Apache Software Foundation</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
